Para importar projetos no Eclipse, use o comando:
    File->Import->Projects from Folder or Archive; ou
    File->Import->Projects from Git.

Atenção! No curso foi utilizada a versão 9 do tomcat.

    A partir da versão 10 do tomcat foram efetuadas mudanças em sua 
    arquitetura, que impossibilitam o import de classes/interfaces do 
    pacote javax.*.

    Com isso, recomendamos que seja utilizada a versão 9 do tomcat, para 
    evitar problemas ao longo do curso.

Comandos no Windows para ver as portas abertas e os programas associados:
    Mostrar a lista de tarefas: 
        D:\>tasklist | findstr cmd

    Mostrar se a porta 8008 está em uso:
        netstat -abno | findstr 8080
            -a => Mostra todas as conexões e portas.
            -b => Mostra o executável envolvido na criação da conexão.
            -n => Exibe endereços e números de porta no formato numérico.
                Útil pra mostrar o IP ao invés do nome do host. E também
                evita de travar o terminal.
            -o => Exibe a ID de processo proprietário associado a cada conexão.

Ctrl + Shift + O => Comando no Eclipse para automatizar importação de pacotes.
Ctrl + M => Maximiza/Restaura a aba atual.
Ctrl + Shift + R => Janela para buscar algum recurso (arquivo)
Alt + Shift + Z => Atalho para "Surround with" em um bloco. Ajuda no try/catch.

Problemas de definição do JRE (a classe System não é localizada, por exemplo):
    Propriedades do Projeto -> Java Build Path -> Aba Libraries. 
        Lá você adapta a JRE que vai ser usada.
    Propriedades do Projeto -> Project Facets.
        Escolha a configuração apropriada para usar o Tomcat.

O objetivo foi substituir vários servlets por um único servlet que recebe as
requisições e as redireciona para classes específicas. (Mas por que criar 
classes que não estendem servlets, já que o método executa seria o mesmo
que service, doPost, doGet etc? Resposta: os métodos dos servlets retornam
void. Para flexibilizar o JSP que vai ser passado para o RequestDispatcher,
os métodos de ação poderiam retornar uma String com o JSP que será chamado).

Ao definir os links para os formulários .jsp, não coloque os parâmetros da
querystring na action do form. Ao invés disso, use campos ocultos com os 
parâmetros da querystring.

Até agora há 3 pacotes no curso:
    * Modelo
    * Servlet
    * Ações

Os dois últimos (Servlet e Ações) fazem parte da camada Controller. O servlet
único redireciona as requisições para as ações correspondentes.

As Ações tem dois comportamentos: ou definem o JSP que vai ser chamado, ou 
redireciona a requisição para outra URI na aplicação. Quem vai fazer qualquer
dos dois comportamentos será a Entrada Única dos servlets.

Preocupação: NUNCA mencionar diretamente qual JSP será carregado. Um meio de 
evitar que o navegador acesse os JSP diretamente é move-los para a pasta
WEB-INF (ela nunca fica acessível pelo navegador).

Para flexibilizar a instanciação do controlador, podemos usar a reflexão Java.
Graças às reflections, podemos instanciar dinamicamente as classes com:
    1) Definir uma interface comum para as ações (vamos chamar de Acao);
    2) Reflection: Class classe = Class.forName("caminho.do.pack.NomeClasse");
    3) Instanciação: Acao acao = (Acao)classe.newInstance();

Problema: Class.forName("classe").newInstance() é deprecated!!! 

Essa forma de criação de objetos é um Design Pattern chamado Command.
